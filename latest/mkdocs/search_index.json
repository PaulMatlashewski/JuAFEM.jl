{
    "docs": [
        {
            "location": "/", 
            "text": "JuAFEM Documentation\n\n\nJuAFEM is a small finite element toolbox that provides a few functionalities to facilitate implementing finite element analyses in Julia.\n\n\nThese functionalities are:\n\n\n\n\nEvaluating shape functions, derivatives of shape functions etc. for different finite element spaces and quadrature rules.\n\n\nEvaluating\n\n\n\n\nExporting to meshes to VTK.\n\n\n\n\n\n\nPackage Manual\n\n\n\n\nInstallation\n\n\nBasic Usage\n\n\n\n\n\n\nAPI\n\n\n\n\nMain Types\n\n\nUtilities\n\n\nQuadratureRule\n\n\nFEValues\n\n\nVTK", 
            "title": "Introduction"
        }, 
        {
            "location": "/#juafem-documentation", 
            "text": "JuAFEM is a small finite element toolbox that provides a few functionalities to facilitate implementing finite element analyses in Julia.  These functionalities are:   Evaluating shape functions, derivatives of shape functions etc. for different finite element spaces and quadrature rules.  Evaluating   Exporting to meshes to VTK.", 
            "title": "JuAFEM Documentation"
        }, 
        {
            "location": "/#package-manual", 
            "text": "Installation  Basic Usage", 
            "title": "Package Manual"
        }, 
        {
            "location": "/#api", 
            "text": "Main Types  Utilities  QuadratureRule  FEValues  VTK", 
            "title": "API"
        }, 
        {
            "location": "/man/installation/", 
            "text": "Installation\n\n\nTo install, simply run\n\n\nPkg.clone(\nhttps://github.com/KristofferC/ContMechTensors.jl\n)\nPkg.clone(\nhttps://github.com/KristofferC/JuAFEM.jl\n)\n\n\n\n\n\nWhen \nContMechTensors\n is a registered package, the first clone statement will not be needed.", 
            "title": "Installation"
        }, 
        {
            "location": "/man/installation/#installation", 
            "text": "To install, simply run  Pkg.clone( https://github.com/KristofferC/ContMechTensors.jl )\nPkg.clone( https://github.com/KristofferC/JuAFEM.jl )  When  ContMechTensors  is a registered package, the first clone statement will not be needed.", 
            "title": "Installation"
        }, 
        {
            "location": "/man/basic_usage/", 
            "text": "Basic Usage\n\n\nCreate a quadrature rule:\n\n\njulia\n \nquad_rule\n \n=\n \nQuadratureRule\n(:\nlegendre\n,\n \nDim\n{\n2\n},\n \nRefCube\n(),\n \n2\n);\n\n\n\n\n\n\nCreate a function space\n\n\njulia\n \nfunc_space\n \n=\n \nLagrange\n{\n2\n,\n \nRefCube\n,\n \n1\n}()\n\n\n\n\n\n\nUse these to create a \nFEValues\n object.\n\n\njulia\n \nfe_values\n \n=\n \nFEValues\n(\nquad_rule\n,\n \nfunc_space\n);\n\n\n\n\n\n\nUse \nreinit!\n to update \nfe_values\n on an element:\n\n\njulia\n \nx\n \n=\n \nVec\n{\n2\n,\n \nFloat64\n}[\nVec\n{\n2\n}((\n0.0\n,\n \n0.0\n)),\n\n                           \nVec\n{\n2\n}((\n1.5\n,\n \n0.0\n)),\n\n                           \nVec\n{\n2\n}((\n2.0\n,\n \n2.0\n)),\n\n                           \nVec\n{\n2\n}((\n0.0\n,\n \n1.0\n))];\n\n\n\njulia\n \nreinit!\n(\nfe_values\n,\n \nx\n);\n\n\n\n\n\n\nWe can now query the \nFEValues\n object for shape function information:\n\n\nValues of shape functions in quadrature point 3\n\n\njulia\n \nshape_value\n(\nfe_values\n,\n \n3\n)\n\n\n4\n-\nelement\n \nArray\n{\nFloat64\n,\n1\n}:\n\n \n0.166667\n\n \n0.0446582\n\n \n0.166667\n\n \n0.622008\n\n\n\n\n\n\nDerivatives of shape function 2 in quadrature point 1\n\n\n \njulia\n \nshape_gradient\n(\nfe_values\n,\n \n1\n,\n \n2\n)\n\n\n2\n-\nelement\n \nContMechTensors\n.\nTensor\n{\n1\n,\n2\n,\nFloat64\n,\n2\n}:\n\n  \n0.520116\n\n \n-\n0.219827\n\n\n\n\n\n\nWe can also evaluate values and gradients of functions on the finite element basis:\n\n\njulia\n \nT\n \n=\n \n[\n0.0\n,\n \n1.0\n,\n \n2.0\n,\n \n1.5\n];\n\n\n\njulia\n \nfunction_scalar_value\n(\nfe_values\n,\n \n3\n,\n \nT\n)\n \n# value of T in 3rd quad point\n\n\n1.311004233964073\n\n\n\njulia\n \nfunction_scalar_gradient\n(\nfe_values\n,\n \n1\n,\n \nT\n)\n  \n# value of grad T in 1st quad point\n\n\n2\n-\nelement\n \nContMechTensors\n.\nTensor\n{\n1\n,\n2\n,\nFloat64\n,\n2\n}:\n\n \n0.410202\n\n \n1.1153\n\n\n\n\n\n\nFor a vector valued function:\n\n\njulia\n \nu\n \n=\n \nVec\n{\n2\n,\n \nFloat64\n}[\nVec\n{\n2\n}((\n0.0\n,\n \n0.0\n)),\n\n                          \nVec\n{\n2\n}((\n3.5\n,\n \n2.0\n)),\n\n                          \nVec\n{\n2\n}((\n2.0\n,\n \n2.0\n)),\n\n                          \nVec\n{\n2\n}((\n2.0\n,\n \n1.0\n))];\n\n\n\njulia\n \nfunction_vector_value\n(\nfe_values\n,\n \n2\n,\n \nu\n)\n\n\n2\n-\nelement\n \nContMechTensors\n.\nTensor\n{\n1\n,\n2\n,\nFloat64\n,\n2\n}:\n\n \n2.59968\n\n \n1.62201\n\n\n\njulia\n \nfunction_vector_symmetric_gradient\n(\nfe_values\n,\n \n3\n,\n \nu\n)\n\n\n2\nx2\n \nContMechTensors\n.\nSymmetricTensor\n{\n2\n,\n2\n,\nFloat64\n,\n3\n}:\n\n \n-\n0.0443518\n  \n0.713306\n\n  \n0.713306\n   \n0.617741\n\n\n\n\n\n\nFor more functions see  the documentation for \nFEValues", 
            "title": "Basic usage"
        }, 
        {
            "location": "/man/basic_usage/#basic-usage", 
            "text": "Create a quadrature rule:  julia   quad_rule   =   QuadratureRule (: legendre ,   Dim { 2 },   RefCube (),   2 );   Create a function space  julia   func_space   =   Lagrange { 2 ,   RefCube ,   1 }()   Use these to create a  FEValues  object.  julia   fe_values   =   FEValues ( quad_rule ,   func_space );   Use  reinit!  to update  fe_values  on an element:  julia   x   =   Vec { 2 ,   Float64 }[ Vec { 2 }(( 0.0 ,   0.0 )), \n                            Vec { 2 }(( 1.5 ,   0.0 )), \n                            Vec { 2 }(( 2.0 ,   2.0 )), \n                            Vec { 2 }(( 0.0 ,   1.0 ))];  julia   reinit! ( fe_values ,   x );   We can now query the  FEValues  object for shape function information:  Values of shape functions in quadrature point 3  julia   shape_value ( fe_values ,   3 )  4 - element   Array { Float64 , 1 }: \n  0.166667 \n  0.0446582 \n  0.166667 \n  0.622008   Derivatives of shape function 2 in quadrature point 1    julia   shape_gradient ( fe_values ,   1 ,   2 )  2 - element   ContMechTensors . Tensor { 1 , 2 , Float64 , 2 }: \n   0.520116 \n  - 0.219827   We can also evaluate values and gradients of functions on the finite element basis:  julia   T   =   [ 0.0 ,   1.0 ,   2.0 ,   1.5 ];  julia   function_scalar_value ( fe_values ,   3 ,   T )   # value of T in 3rd quad point  1.311004233964073  julia   function_scalar_gradient ( fe_values ,   1 ,   T )    # value of grad T in 1st quad point  2 - element   ContMechTensors . Tensor { 1 , 2 , Float64 , 2 }: \n  0.410202 \n  1.1153   For a vector valued function:  julia   u   =   Vec { 2 ,   Float64 }[ Vec { 2 }(( 0.0 ,   0.0 )), \n                           Vec { 2 }(( 3.5 ,   2.0 )), \n                           Vec { 2 }(( 2.0 ,   2.0 )), \n                           Vec { 2 }(( 2.0 ,   1.0 ))];  julia   function_vector_value ( fe_values ,   2 ,   u )  2 - element   ContMechTensors . Tensor { 1 , 2 , Float64 , 2 }: \n  2.59968 \n  1.62201  julia   function_vector_symmetric_gradient ( fe_values ,   3 ,   u )  2 x2   ContMechTensors . SymmetricTensor { 2 , 2 , Float64 , 3 }: \n  - 0.0443518    0.713306 \n   0.713306     0.617741   For more functions see  the documentation for  FEValues", 
            "title": "Basic Usage"
        }, 
        {
            "location": "/lib/maintypes/", 
            "text": "Main Types\n\n\n\n\nJuAFEM.AbstractRefShape\n\n\nJuAFEM.Dim\n\n\nJuAFEM.FEValues\n\n\nJuAFEM.FunctionSpace\n\n\nJuAFEM.QuadratureRule\n\n\n\n\n#\n\n\nJuAFEM.Dim\n \n \nType\n.\n\n\nSingleton type that is similar to \nVal\n in Base but with a more descriptive name. Used to construct some types in a type stable way.\n\n\nsource\n\n\n#\n\n\nJuAFEM.AbstractRefShape\n \n \nType\n.\n\n\nRepresents a reference shape which quadrature rules and function spaces are defined on. Currently, the only concrete types that subtype this type is \nRefTetrahedron\n and \nRefCube\n.\n\n\nsource\n\n\n#\n\n\nJuAFEM.QuadratureRule\n \n \nType\n.\n\n\nA \nQuadratureRule\n is a way to approximate an integral on a domain by a weighted sum of function values at specific points:\n\n\n$\\int\\limits_\\Omega f(\\mathbf{x}) d \\Omega \\approx \\sum\\limits_{q = 1}^{n_q} f(\\mathbf{x}_q) w_q$\n\n\nThe quadrature rule consists of $n_q$ points in space $\\mathbf{x}_q$ with corresponding weights $w_q$.\n\n\nIn \nJuaFEM\n, the \nQuadratureRule\n type is mostly used as one of the components to create a \nFEValues\n object.\n\n\nConstructors:\n\n\nQuadratureRule([quad_rule_type::Symbol], ::Dim{dim}, ref_shape::Shape, order::Int)\n\n\n\n\n\nArguments:\n\n\n\n\nquad_rule_type\n: The type of the quadrature rule. Currently only \n:legendre\n or \n:lobatto\n types are supported where\n\n\n\n\n:lobatto\n is only supported for \nRefCube\n. If the quadrature rule type is left out, \n:legendre\n is used. * \n::Dim{dim}\n the dimension of the reference shape * \nref_shape\n: the reference shape * \norder\n: the order of the quadrature rule\n\n\nCommon methods:\n\n\n\n\npoints\n : the points of the quadrature rule\n\n\nweights\n : the weights of the quadrature rule\n\n\n\n\nExample:\n\n\njulia\n \nQuadratureRule\n(\nDim\n{\n2\n},\n \nRefTetrahedron\n(),\n \n1\n)\n\n\nJuAFEM\n.\nQuadratureRule\n{\n2\n,\nFloat64\n}([\n0.5\n],[[\n0.33333333333333\n,\n0.33333333333333\n]])\n\n\n\njulia\n \nQuadratureRule\n(:\nlobatto\n,\n \nDim\n{\n1\n},\n \nRefCube\n(),\n \n2\n)\n\n\nJuAFEM\n.\nQuadratureRule\n{\n1\n,\nFloat64\n}([\n1.0\n,\n1.0\n],[[\n-\n1.0\n],[\n1.0\n]])\n\n\n\n\n\n\nsource\n\n\n#\n\n\nJuAFEM.FunctionSpace\n \n \nType\n.\n\n\nConstructor:\n\n\nFunctionSpace{dim, reference_shape, order}()\n\n\n\n\n\nParameters:\n\n\n\n\ndim\n The dimension the function space lives in\n\n\nshape\n A reference shape, see \nAbstractRefShape\n\n\norder\n The highest order term in the polynomial\n\n\n\n\nThe following function spaces are implemented:\n\n\n\n\nLagrange{1, RefCube, 1}\n\n\nLagrange{1, RefCube, 2}\n\n\nLagrange{2, RefCube, 1}\n\n\nLagrange{2, RefTetrahedron, 1}\n\n\nLagrange{2, RefTetrahedron, 2}\n\n\nLagrange{3, RefCube, 1}\n\n\nSerendipity{2, RefCube, 2}\n\n\nLagrange{3, RefTetrahedron, 1}\n\n\n\n\nsource\n\n\n#\n\n\nJuAFEM.FEValues\n \n \nType\n.\n\n\nAn \nFEValues\n object facilitates the process of evaluating values shape functions, gradients of shape functions, values of nodal functions, gradients and divergences of nodal functions etc.\n\n\nConstructor\n\n\nFEValues([::Type{T}], quad_rule::QuadratureRule, function_space::FunctionSpace)\n\n\n\n\n\nArguments\n\n\n\n\nT\n an optional argument to determine the type the internal data is stored as.\n\n\nquad_rule\n an instance of a \nQuadratureRule\n\n\nfunction_space\n an instance of a \nFunctionSpace\n\n\n\n\n Common methods\n\n\n\n\nget_quadrule\n\n\nget_functionspace\n\n\ndetJdV\n\n\nshape_value\n\n\nshape_gradient\n\n\nshape_divergence\n\n\nshape_derivative\n\n\nfunction_scalar_value\n\n\nfunction_vector_value\n\n\nfunction_scalar_gradient\n\n\nfunction_vector_divergence\n\n\nfunction_vector_gradient\n\n\nfunction_vector_symmetric_gradient\n\n\n\n\nsource", 
            "title": "Main types"
        }, 
        {
            "location": "/lib/maintypes/#main-types", 
            "text": "JuAFEM.AbstractRefShape  JuAFEM.Dim  JuAFEM.FEValues  JuAFEM.FunctionSpace  JuAFEM.QuadratureRule   #  JuAFEM.Dim     Type .  Singleton type that is similar to  Val  in Base but with a more descriptive name. Used to construct some types in a type stable way.  source  #  JuAFEM.AbstractRefShape     Type .  Represents a reference shape which quadrature rules and function spaces are defined on. Currently, the only concrete types that subtype this type is  RefTetrahedron  and  RefCube .  source  #  JuAFEM.QuadratureRule     Type .  A  QuadratureRule  is a way to approximate an integral on a domain by a weighted sum of function values at specific points:  $\\int\\limits_\\Omega f(\\mathbf{x}) d \\Omega \\approx \\sum\\limits_{q = 1}^{n_q} f(\\mathbf{x}_q) w_q$  The quadrature rule consists of $n_q$ points in space $\\mathbf{x}_q$ with corresponding weights $w_q$.  In  JuaFEM , the  QuadratureRule  type is mostly used as one of the components to create a  FEValues  object.  Constructors:  QuadratureRule([quad_rule_type::Symbol], ::Dim{dim}, ref_shape::Shape, order::Int)  Arguments:   quad_rule_type : The type of the quadrature rule. Currently only  :legendre  or  :lobatto  types are supported where   :lobatto  is only supported for  RefCube . If the quadrature rule type is left out,  :legendre  is used. *  ::Dim{dim}  the dimension of the reference shape *  ref_shape : the reference shape *  order : the order of the quadrature rule  Common methods:   points  : the points of the quadrature rule  weights  : the weights of the quadrature rule   Example:  julia   QuadratureRule ( Dim { 2 },   RefTetrahedron (),   1 )  JuAFEM . QuadratureRule { 2 , Float64 }([ 0.5 ],[[ 0.33333333333333 , 0.33333333333333 ]])  julia   QuadratureRule (: lobatto ,   Dim { 1 },   RefCube (),   2 )  JuAFEM . QuadratureRule { 1 , Float64 }([ 1.0 , 1.0 ],[[ - 1.0 ],[ 1.0 ]])   source  #  JuAFEM.FunctionSpace     Type .  Constructor:  FunctionSpace{dim, reference_shape, order}()  Parameters:   dim  The dimension the function space lives in  shape  A reference shape, see  AbstractRefShape  order  The highest order term in the polynomial   The following function spaces are implemented:   Lagrange{1, RefCube, 1}  Lagrange{1, RefCube, 2}  Lagrange{2, RefCube, 1}  Lagrange{2, RefTetrahedron, 1}  Lagrange{2, RefTetrahedron, 2}  Lagrange{3, RefCube, 1}  Serendipity{2, RefCube, 2}  Lagrange{3, RefTetrahedron, 1}   source  #  JuAFEM.FEValues     Type .  An  FEValues  object facilitates the process of evaluating values shape functions, gradients of shape functions, values of nodal functions, gradients and divergences of nodal functions etc.  Constructor  FEValues([::Type{T}], quad_rule::QuadratureRule, function_space::FunctionSpace)  Arguments   T  an optional argument to determine the type the internal data is stored as.  quad_rule  an instance of a  QuadratureRule  function_space  an instance of a  FunctionSpace    Common methods   get_quadrule  get_functionspace  detJdV  shape_value  shape_gradient  shape_divergence  shape_derivative  function_scalar_value  function_vector_value  function_scalar_gradient  function_vector_divergence  function_vector_gradient  function_vector_symmetric_gradient   source", 
            "title": "Main Types"
        }, 
        {
            "location": "/lib/utility_functions/", 
            "text": "Utilities\n\n\n\n\nJuAFEM.detJdV\n\n\nJuAFEM.function_scalar_gradient\n\n\nJuAFEM.function_scalar_value\n\n\nJuAFEM.function_vector_divergence\n\n\nJuAFEM.function_vector_gradient\n\n\nJuAFEM.function_vector_symmetric_gradient\n\n\nJuAFEM.function_vector_value\n\n\nJuAFEM.get_functionspace\n\n\nJuAFEM.get_quadrule\n\n\nJuAFEM.points\n\n\nJuAFEM.shape_derivative\n\n\nJuAFEM.shape_divergence\n\n\nJuAFEM.shape_gradient\n\n\nJuAFEM.shape_value\n\n\nJuAFEM.weights\n\n\nWriteVTK.vtk_grid\n\n\n\n\n\n\nQuadratureRule\n\n\n#\n\n\nJuAFEM.points\n \n \nFunction\n.\n\n\nThe points of the quadrature rule.\n\n\npoints(qr::QuadratureRule)\n\n\n\n\n\nArguments:\n\n\n\n\nqr\n: the quadrature rule\n\n\n\n\nExample:\n\n\njulia\n \npoints\n(\nQuadratureRule\n(:\nlegendre\n,\n \nDim\n{\n2\n},\n \nRefTetrahedron\n(),\n \n2\n))\n\n\n3\n-\nelement\n \nArray\n{\nContMechTensors\n.\nTensor\n{\n1\n,\n2\n,\nFloat64\n,\n2\n},\n1\n}:\n\n \n[\n0.166667\n,\n0.166667\n]\n\n \n[\n0.166667\n,\n0.666667\n]\n\n \n[\n0.666667\n,\n0.166667\n]\n\n\n\n\n\n\nsource\n\n\n#\n\n\nJuAFEM.weights\n \n \nFunction\n.\n\n\nThe weights of the quadrature rule.\n\n\nweights(qr::QuadratureRule) = qr.weights\n\n\n\n\n\nArguments:\n\n\n\n\nqr\n: the quadrature rule\n\n\n\n\nExample:\n\n\njulia\n \nweights\n(\nQuadratureRule\n(:\nlegendre\n,\n \nDim\n{\n2\n},\n \nRefTetrahedron\n(),\n \n2\n))\n\n\n3\n-\nelement\n \nArray\n{\nFloat64\n,\n1\n}:\n\n \n0.166667\n\n \n0.166667\n\n \n0.166667\n\n\n\n\n\n\nsource\n\n\n\n\nFEValues\n\n\n#\n\n\nJuAFEM.get_quadrule\n \n \nFunction\n.\n\n\nThe quadrature rule for the \nFEValues\n type.\n\n\nget_quadrule(fe_v::FEValues)\n\n\n\n\n\n Arguments \n\n\n\n\nfe_values\n: the \nFEValues\n object\n\n\n\n\n Results \n\n\n\n\n::QuadratureRule\n: the quadrature rule.\n\n\n\n\nsource\n\n\n#\n\n\nJuAFEM.get_functionspace\n \n \nFunction\n.\n\n\nThe function space for the \nFEValues\n type.\n\n\nArguments\n\n\n\n\nfe_values\n: the \nFEValues\n object\n\n\n\n\nResults\n\n\n\n\n::FunctionSpace\n: the function space\n\n\n\n\nsource\n\n\n#\n\n\nJuAFEM.detJdV\n \n \nFunction\n.\n\n\nThe product between the determinant of the Jacobian and the quadrature point weight for a given quadrature point: $\\det(J(\\mathbf{x})) w_q$\n\n\ndetJdV(fe_v::FEValues, quadrature_point::Int)\n\n\n\n\n\n Arguments:\n\n\n\n\nfe_values\n: the \nFEValues\n object\n\n\nquadrature_point\n The quadrature point number\n\n\n\n\nResults:\n\n\n\n\n::Number\n\n\n\n\nDetails:\n\n\nThis value is typically used when one integrates a function on a finite element as\n\n\n$\\int\\limits_\\Omega f(\\mathbf{x}) d \\Omega \\approx \\sum\\limits_{q = 1}^{n_q} f(\\mathbf{x}_q) \\det(J(\\mathbf{x})) w_q$\n\n\nsource\n\n\n#\n\n\nJuAFEM.shape_value\n \n \nFunction\n.\n\n\nComputes the value of the shape function     shape_value(fe_v::FEValues, quadrature_point::Int, [base_function::Int])\n\n\nGets the values of the shape function for a given quadrature point and base_func\n\n\nsource\n\n\n#\n\n\nJuAFEM.shape_gradient\n \n \nFunction\n.\n\n\nGet the gradients of the shape functions for a given quadrature point\n\n\nsource\n\n\nGet the gradient of the shape functions for a given quadrature point and base function\n\n\nsource\n\n\n#\n\n\nJuAFEM.shape_divergence\n \n \nFunction\n.\n\n\nGet the divergence of the shape functions for a given quadrature point and base function\n\n\nsource\n\n\n#\n\n\nJuAFEM.shape_derivative\n \n \nFunction\n.\n\n\nGet the gradients of the shape functions for a given quadrature point\n\n\nsource\n\n\nGet the gradient of the shape functions for a given quadrature point and base function\n\n\nsource\n\n\n#\n\n\nJuAFEM.function_scalar_value\n \n \nFunction\n.\n\n\nComputes the value in a quadrature point for a scalar valued function\n\n\nfunction_scalar_value{dim, T}(fe_v::FEValues{dim}, q_point::Int, u::Vector{T})\n\n\n\n\n\nArguments:\n\n\n\n\nfe_v\n: the \nFEValues\n object\n\n\nq_point\n: the quadrature point number\n\n\nu\n: the value of the function in the nodes\n\n\n\n\nResults:\n\n\n\n\n::Number\n: the value of the function\n\n\n\n\nDetails:\n\n\nThe value of a scalar valued function is computed as $T(\\mathbf{x}) = \\sum\\limits_{i = 1}^n N_i (\\mathbf{x}) T_i$\n\n\nsource\n\n\n#\n\n\nJuAFEM.function_vector_value\n \n \nFunction\n.\n\n\nfunction_vector_value{dim, T}(fe_v::FEValues{dim}, q_point::Int, u::Vector{Vec{dim, T}})\n\n\n\n\n\nComputes the value in a quadrature point for a vector valued function.\n\n\nArguments:\n\n\n\n\nfe_v\n: the \nFEValues\n object\n\n\nq_point\n: the quadrature point number\n\n\nu\n: the value of the function in the nodes\n\n\n\n\nResults:\n\n\n\n\n::Vec{dim, T}\n: the value of the function\n\n\n\n\nDetails:\n\n\nThe value of a vector valued function is computed as $\\mathbf{u}(\\mathbf{x}) = \\sum\\limits_{i = 1}^n N_i (\\mathbf{x}) \\mathbf{u}_i$\n\n\nsource\n\n\n#\n\n\nJuAFEM.function_scalar_gradient\n \n \nFunction\n.\n\n\nfunction_scalar_gradien{dim, T}t(fe_v::FEValues{dim}, q_point::Int, u::Vector{T}) -\n grad::Tensor{1}\n\n\n\n\n\nComputes the gradient for a scalar valued function in a quadrature point .\n\n\nArguments:\n\n\n\n\nfe_v\n: the \nFEValues\n object\n\n\nq_point\n: the quadrature point number\n\n\nu\n: the value of the function in the nodes\n\n\n\n\nResults:\n\n\n\n\n::Vec{dim, T}\n: the gradient\n\n\n\n\nDetails:\n\n\nThe gradient of a scalar function is computed as $\\mathbf{\\nabla} T(\\mathbf{x}) = \\sum\\limits_{i = 1}^n \\mathbf{\\nabla} N_i (\\mathbf{x}) T_i$ where $T_i$ are the nodal values of the function.\n\n\nsource\n\n\n#\n\n\nJuAFEM.function_vector_divergence\n \n \nFunction\n.\n\n\nComputes the divergence in a quadrature point for a vector valued function.\n\n\nfunction_vector_divergence{dim, T}(fe_v::FEValues{dim}, q_point::Int, u::Vector{Vec{dim, T}})\n\n\n\n\n\nArguments:\n\n\n\n\nfe_v\n: the \nFEValues\n object\n\n\nq_point\n: the quadrature point number\n\n\nu\n: the value of the function in the nodes\n\n\n\n\nResults:\n\n\n\n\n::Number\n: the divergence of the function\n\n\n\n\nDetails:\n\n\nThe divergence of a vector valued functions in the quadrature point $\\mathbf{x}_q)$ is computed as\n\n\n$\\mathbf{\\nabla} \\cdot \\mathbf{u}(\\mathbf{x_q}) = \\sum\\limits_{i = 1}^n \\mathbf{\\nabla} N_i (\\mathbf{x_q}) \\cdot \\mathbf{u}_i$\n\n\nwhere $\\mathbf{u}_i$ are the nodal values of the function.\n\n\nsource\n\n\n#\n\n\nJuAFEM.function_vector_gradient\n \n \nFunction\n.\n\n\nComputes the gradient for a vector valued function in a quadrature point.\n\n\nfunction_vector_gradient{dim, T}(fe_v::FEValues{dim}, q_point::Int, u::Vector{Vec{dim, T}})\n\n\n\n\n\nArguments:\n\n\n\n\nfe_v\n: the \nFEValues\n object\n\n\nq_point\n: the quadrature point number\n\n\nu\n: the value of the function in the nodes\n\n\n\n\nResults:\n\n\n\n\n::Tensor{2, dim, T}\n: the gradient\n\n\n\n\nDetails:\n\n\nThe gradient of a scalar function is computed as $\\mathbf{\\nabla} \\mathbf{u}(\\mathbf{x}) = \\sum\\limits_{i = 1}^n \\mathbf{\\nabla} N_i (\\mathbf{x}) \\otimes \\mathbf{u}_i$ where $\\mathbf{u}_i$ are the nodal values of the function.\n\n\nsource\n\n\n#\n\n\nJuAFEM.function_vector_symmetric_gradient\n \n \nFunction\n.\n\n\nComputes the gradient for a vector valued function in a quadrature point.\n\n\nfunction_vector_symmetric_gradient{dim, T}(fe_v::FEValues{dim}, q_point::Int, u::Vector{Vec{dim, T}})\n\n\n\n\n\nArguments:\n\n\n\n\nfe_v\n: the \nFEValues\n object\n\n\nq_point\n: the quadrature point number\n\n\nu\n: the value of the function in the nodes\n\n\n\n\nResults:\n\n\n\n\n::SymmetricTensor{2, dim, T}\n: the symmetric gradient\n\n\n\n\nDetails:\n\n\nThe symmetric gradient of a scalar function is computed as\n\n\n$\\left[ \\mathbf{\\nabla}  \\mathbf{u}(\\mathbf{x_q}) \\right]^\\text{sym} =  \\sum\\limits_{i = 1}^n  \\frac{1}{2} \\left[ \\mathbf{\\nabla} N_i (\\mathbf{x}_q) \\otimes \\mathbf{u}_i + \\mathbf{u}_i  \\otimes  \\mathbf{\\nabla} N_i (\\mathbf{x}_q) \\right]$\n\n\nwhere $\\mathbf{u}_i$ are the nodal values of the function.\n\n\nsource\n\n\n\n\nVTK\n\n\n#\n\n\nWriteVTK.vtk_grid\n \n \nFunction\n.\n\n\nCreates an unstructured VTK grid from the element topology and coordinates.\n\n\nvtk_grid(topology::Matrix{Int}, coord::Matrix, filename::AbstractString)\n\n\n\n\n\nArguments\n\n\n\n\ntopology\n A matrix where each column contains the vertices of the element\n\n\ncoord\n A matrix of the coordinates, one column per coordinate\n\n\nfilename\n: Name of the file when it is saved to disk\n\n\n\n\nResults:\n\n\n\n\n::DatasetFile\n\n\n\n\nExample:\n\n\njulia\n \ncoords\n \n=\n \n[\n0.0\n \n0.0\n;\n \n1.0\n \n0.0\n;\n \n0.5\n \n1.0\n;\n \n1.5\n \n1.0\n]\n\n\n2\nx4\n \nArray\n{\nFloat64\n,\n2\n}:\n\n \n0.0\n  \n1.0\n  \n0.5\n  \n1.5\n\n \n0.0\n  \n0.0\n  \n1.0\n  \n1.0\n\n\n\njulia\n \ntopology\n \n=\n \n[\n1\n \n2\n \n3\n;\n \n2\n \n4\n \n3\n]\n\n\n3\nx2\n \nArray\n{\nInt64\n,\n2\n}:\n\n \n1\n  \n2\n\n \n2\n  \n4\n\n \n3\n  \n3\n\n\n\njulia\n \nvtkobj\n \n=\n \nvtk_grid\n(\ntopology\n,\n \ncoords\n,\n \nexample\n);\n\n\n\njulia\n \nvtk_save\n(\nvtkobj\n)\n\n\n1\n-\nelement\n \nArray\n{\nUTF8String\n,\n1\n}:\n\n \nexample.vtu\n\n\n\n\n\n\nDetails\n\n\nThis is a thin wrapper around the \nvtk_grid\n function from the \nWriteVTK\n package.\n\n\nFor infromation how to add cell data and point data to the resulting VTK object as well as how to write it to a file see \nhttps://github.com/jipolanco/WriteVTK.jl#generating-an-unstructured-vtk-file\n\n\nsource", 
            "title": "Utility functions"
        }, 
        {
            "location": "/lib/utility_functions/#utilities", 
            "text": "JuAFEM.detJdV  JuAFEM.function_scalar_gradient  JuAFEM.function_scalar_value  JuAFEM.function_vector_divergence  JuAFEM.function_vector_gradient  JuAFEM.function_vector_symmetric_gradient  JuAFEM.function_vector_value  JuAFEM.get_functionspace  JuAFEM.get_quadrule  JuAFEM.points  JuAFEM.shape_derivative  JuAFEM.shape_divergence  JuAFEM.shape_gradient  JuAFEM.shape_value  JuAFEM.weights  WriteVTK.vtk_grid", 
            "title": "Utilities"
        }, 
        {
            "location": "/lib/utility_functions/#quadraturerule", 
            "text": "#  JuAFEM.points     Function .  The points of the quadrature rule.  points(qr::QuadratureRule)  Arguments:   qr : the quadrature rule   Example:  julia   points ( QuadratureRule (: legendre ,   Dim { 2 },   RefTetrahedron (),   2 ))  3 - element   Array { ContMechTensors . Tensor { 1 , 2 , Float64 , 2 }, 1 }: \n  [ 0.166667 , 0.166667 ] \n  [ 0.166667 , 0.666667 ] \n  [ 0.666667 , 0.166667 ]   source  #  JuAFEM.weights     Function .  The weights of the quadrature rule.  weights(qr::QuadratureRule) = qr.weights  Arguments:   qr : the quadrature rule   Example:  julia   weights ( QuadratureRule (: legendre ,   Dim { 2 },   RefTetrahedron (),   2 ))  3 - element   Array { Float64 , 1 }: \n  0.166667 \n  0.166667 \n  0.166667   source", 
            "title": "QuadratureRule"
        }, 
        {
            "location": "/lib/utility_functions/#fevalues", 
            "text": "#  JuAFEM.get_quadrule     Function .  The quadrature rule for the  FEValues  type.  get_quadrule(fe_v::FEValues)   Arguments    fe_values : the  FEValues  object    Results    ::QuadratureRule : the quadrature rule.   source  #  JuAFEM.get_functionspace     Function .  The function space for the  FEValues  type.  Arguments   fe_values : the  FEValues  object   Results   ::FunctionSpace : the function space   source  #  JuAFEM.detJdV     Function .  The product between the determinant of the Jacobian and the quadrature point weight for a given quadrature point: $\\det(J(\\mathbf{x})) w_q$  detJdV(fe_v::FEValues, quadrature_point::Int)   Arguments:   fe_values : the  FEValues  object  quadrature_point  The quadrature point number   Results:   ::Number   Details:  This value is typically used when one integrates a function on a finite element as  $\\int\\limits_\\Omega f(\\mathbf{x}) d \\Omega \\approx \\sum\\limits_{q = 1}^{n_q} f(\\mathbf{x}_q) \\det(J(\\mathbf{x})) w_q$  source  #  JuAFEM.shape_value     Function .  Computes the value of the shape function     shape_value(fe_v::FEValues, quadrature_point::Int, [base_function::Int])  Gets the values of the shape function for a given quadrature point and base_func  source  #  JuAFEM.shape_gradient     Function .  Get the gradients of the shape functions for a given quadrature point  source  Get the gradient of the shape functions for a given quadrature point and base function  source  #  JuAFEM.shape_divergence     Function .  Get the divergence of the shape functions for a given quadrature point and base function  source  #  JuAFEM.shape_derivative     Function .  Get the gradients of the shape functions for a given quadrature point  source  Get the gradient of the shape functions for a given quadrature point and base function  source  #  JuAFEM.function_scalar_value     Function .  Computes the value in a quadrature point for a scalar valued function  function_scalar_value{dim, T}(fe_v::FEValues{dim}, q_point::Int, u::Vector{T})  Arguments:   fe_v : the  FEValues  object  q_point : the quadrature point number  u : the value of the function in the nodes   Results:   ::Number : the value of the function   Details:  The value of a scalar valued function is computed as $T(\\mathbf{x}) = \\sum\\limits_{i = 1}^n N_i (\\mathbf{x}) T_i$  source  #  JuAFEM.function_vector_value     Function .  function_vector_value{dim, T}(fe_v::FEValues{dim}, q_point::Int, u::Vector{Vec{dim, T}})  Computes the value in a quadrature point for a vector valued function.  Arguments:   fe_v : the  FEValues  object  q_point : the quadrature point number  u : the value of the function in the nodes   Results:   ::Vec{dim, T} : the value of the function   Details:  The value of a vector valued function is computed as $\\mathbf{u}(\\mathbf{x}) = \\sum\\limits_{i = 1}^n N_i (\\mathbf{x}) \\mathbf{u}_i$  source  #  JuAFEM.function_scalar_gradient     Function .  function_scalar_gradien{dim, T}t(fe_v::FEValues{dim}, q_point::Int, u::Vector{T}) -  grad::Tensor{1}  Computes the gradient for a scalar valued function in a quadrature point .  Arguments:   fe_v : the  FEValues  object  q_point : the quadrature point number  u : the value of the function in the nodes   Results:   ::Vec{dim, T} : the gradient   Details:  The gradient of a scalar function is computed as $\\mathbf{\\nabla} T(\\mathbf{x}) = \\sum\\limits_{i = 1}^n \\mathbf{\\nabla} N_i (\\mathbf{x}) T_i$ where $T_i$ are the nodal values of the function.  source  #  JuAFEM.function_vector_divergence     Function .  Computes the divergence in a quadrature point for a vector valued function.  function_vector_divergence{dim, T}(fe_v::FEValues{dim}, q_point::Int, u::Vector{Vec{dim, T}})  Arguments:   fe_v : the  FEValues  object  q_point : the quadrature point number  u : the value of the function in the nodes   Results:   ::Number : the divergence of the function   Details:  The divergence of a vector valued functions in the quadrature point $\\mathbf{x}_q)$ is computed as  $\\mathbf{\\nabla} \\cdot \\mathbf{u}(\\mathbf{x_q}) = \\sum\\limits_{i = 1}^n \\mathbf{\\nabla} N_i (\\mathbf{x_q}) \\cdot \\mathbf{u}_i$  where $\\mathbf{u}_i$ are the nodal values of the function.  source  #  JuAFEM.function_vector_gradient     Function .  Computes the gradient for a vector valued function in a quadrature point.  function_vector_gradient{dim, T}(fe_v::FEValues{dim}, q_point::Int, u::Vector{Vec{dim, T}})  Arguments:   fe_v : the  FEValues  object  q_point : the quadrature point number  u : the value of the function in the nodes   Results:   ::Tensor{2, dim, T} : the gradient   Details:  The gradient of a scalar function is computed as $\\mathbf{\\nabla} \\mathbf{u}(\\mathbf{x}) = \\sum\\limits_{i = 1}^n \\mathbf{\\nabla} N_i (\\mathbf{x}) \\otimes \\mathbf{u}_i$ where $\\mathbf{u}_i$ are the nodal values of the function.  source  #  JuAFEM.function_vector_symmetric_gradient     Function .  Computes the gradient for a vector valued function in a quadrature point.  function_vector_symmetric_gradient{dim, T}(fe_v::FEValues{dim}, q_point::Int, u::Vector{Vec{dim, T}})  Arguments:   fe_v : the  FEValues  object  q_point : the quadrature point number  u : the value of the function in the nodes   Results:   ::SymmetricTensor{2, dim, T} : the symmetric gradient   Details:  The symmetric gradient of a scalar function is computed as  $\\left[ \\mathbf{\\nabla}  \\mathbf{u}(\\mathbf{x_q}) \\right]^\\text{sym} =  \\sum\\limits_{i = 1}^n  \\frac{1}{2} \\left[ \\mathbf{\\nabla} N_i (\\mathbf{x}_q) \\otimes \\mathbf{u}_i + \\mathbf{u}_i  \\otimes  \\mathbf{\\nabla} N_i (\\mathbf{x}_q) \\right]$  where $\\mathbf{u}_i$ are the nodal values of the function.  source", 
            "title": "FEValues"
        }, 
        {
            "location": "/lib/utility_functions/#vtk", 
            "text": "#  WriteVTK.vtk_grid     Function .  Creates an unstructured VTK grid from the element topology and coordinates.  vtk_grid(topology::Matrix{Int}, coord::Matrix, filename::AbstractString)  Arguments   topology  A matrix where each column contains the vertices of the element  coord  A matrix of the coordinates, one column per coordinate  filename : Name of the file when it is saved to disk   Results:   ::DatasetFile   Example:  julia   coords   =   [ 0.0   0.0 ;   1.0   0.0 ;   0.5   1.0 ;   1.5   1.0 ]  2 x4   Array { Float64 , 2 }: \n  0.0    1.0    0.5    1.5 \n  0.0    0.0    1.0    1.0  julia   topology   =   [ 1   2   3 ;   2   4   3 ]  3 x2   Array { Int64 , 2 }: \n  1    2 \n  2    4 \n  3    3  julia   vtkobj   =   vtk_grid ( topology ,   coords ,   example );  julia   vtk_save ( vtkobj )  1 - element   Array { UTF8String , 1 }: \n  example.vtu   Details  This is a thin wrapper around the  vtk_grid  function from the  WriteVTK  package.  For infromation how to add cell data and point data to the resulting VTK object as well as how to write it to a file see  https://github.com/jipolanco/WriteVTK.jl#generating-an-unstructured-vtk-file  source", 
            "title": "VTK"
        }, 
        {
            "location": "/LICENSE/", 
            "text": "The JuAFEM.jl package is licensed under the MIT \"Expat\" License:\n\n\n\n\nCopyright (c) 2015-2016: Kristoffer Carlsson.\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.", 
            "title": "License"
        }
    ]
}