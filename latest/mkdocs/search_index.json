{
    "docs": [
        {
            "location": "/", 
            "text": "JuAFEM Documentation\n\n\nJuAFEM is a small finite element toolbox that provides a few functionalities to facilitate implementing finite element analyses in Julia.\n\n\nThese functionalities are:\n\n\n\n\nEvaluating shape functions, derivatives of shape functions etc. for different finite element spaces and quadrature rules.\n\n\nEvaluating\n\n\n\n\nExporting to meshes to VTK.\n\n\n\n\n\n\nPackage Manual\n\n\n\n\nInstallation\n\n\nBasic Usage\n\n\n\n\n\n\nAPI\n\n\n\n\nMain Types\n\n\nUtilities\n\n\nQuadratureRule\n\n\nFEValues\n\n\nVTK", 
            "title": "Introduction"
        }, 
        {
            "location": "/#juafem-documentation", 
            "text": "JuAFEM is a small finite element toolbox that provides a few functionalities to facilitate implementing finite element analyses in Julia.  These functionalities are:   Evaluating shape functions, derivatives of shape functions etc. for different finite element spaces and quadrature rules.  Evaluating   Exporting to meshes to VTK.", 
            "title": "JuAFEM Documentation"
        }, 
        {
            "location": "/#package-manual", 
            "text": "Installation  Basic Usage", 
            "title": "Package Manual"
        }, 
        {
            "location": "/#api", 
            "text": "Main Types  Utilities  QuadratureRule  FEValues  VTK", 
            "title": "API"
        }, 
        {
            "location": "/man/installation/", 
            "text": "Installation\n\n\nTo install, simply run\n\n\nPkg.clone(\nhttps://github.com/KristofferC/ContMechTensors.jl\n)\nPkg.clone(\nhttps://github.com/KristofferC/JuAFEM.jl\n)\n\n\n\n\n\nWhen \nContMechTensors\n is a registered package, the first clone statement will not be needed.", 
            "title": "Installation"
        }, 
        {
            "location": "/man/installation/#installation", 
            "text": "To install, simply run  Pkg.clone( https://github.com/KristofferC/ContMechTensors.jl )\nPkg.clone( https://github.com/KristofferC/JuAFEM.jl )  When  ContMechTensors  is a registered package, the first clone statement will not be needed.", 
            "title": "Installation"
        }, 
        {
            "location": "/man/basic_usage/", 
            "text": "Basic Usage\n\n\nCreate a quadrature rule:\n\n\njulia\n \nquad_rule\n \n=\n \nQuadratureRule\n(:\nlegendre\n,\n \nDim\n{\n2\n},\n \nRefCube\n(),\n \n2\n);\n\n\n\n\n\n\nCreate a function space\n\n\njulia\n \nfunc_space\n \n=\n \nLagrange\n{\n2\n,\n \nRefCube\n,\n \n1\n}()\n\n\n\n\n\n\nUse these to create a \nFEValues\n object.\n\n\njulia\n \nfe_values\n \n=\n \nFEValues\n(\nquad_rule\n,\n \nfunc_space\n);\n\n\n\n\n\n\nUse \nreinit!\n to update \nfe_values\n on an element:\n\n\njulia\n \nx\n \n=\n \nVec\n{\n2\n,\n \nFloat64\n}[\nVec\n{\n2\n}((\n0.0\n,\n \n0.0\n)),\n\n                           \nVec\n{\n2\n}((\n1.5\n,\n \n0.0\n)),\n\n                           \nVec\n{\n2\n}((\n2.0\n,\n \n2.0\n)),\n\n                           \nVec\n{\n2\n}((\n0.0\n,\n \n1.0\n))];\n\n\n\njulia\n \nreinit!\n(\nfe_values\n,\n \nx\n);\n\n\n\n\n\n\nWe can now query the \nFEValues\n object for shape function information:\n\n\nValues of shape functions in quadrature point 3\n\n\njulia\n \nshape_value\n(\nfe_values\n,\n \n3\n)\n\n\n4\n-\nelement\n \nArray\n{\nFloat64\n,\n1\n}:\n\n \n0.166667\n\n \n0.0446582\n\n \n0.166667\n\n \n0.622008\n\n\n\n\n\n\nDerivatives of shape function 2 in quadrature point 1\n\n\n \njulia\n \nshape_gradient\n(\nfe_values\n,\n \n1\n,\n \n2\n)\n\n\n2\n-\nelement\n \nContMechTensors\n.\nTensor\n{\n1\n,\n2\n,\nFloat64\n,\n2\n}:\n\n  \n0.520116\n\n \n-\n0.219827\n\n\n\n\n\n\nWe can also evaluate values and gradients of functions on the finite element basis:\n\n\njulia\n \nT\n \n=\n \n[\n0.0\n,\n \n1.0\n,\n \n2.0\n,\n \n1.5\n];\n\n\n\njulia\n \nfunction_scalar_value\n(\nfe_values\n,\n \n3\n,\n \nT\n)\n \n# value of T in 3rd quad point\n\n\n1.311004233964073\n\n\n\njulia\n \nfunction_scalar_gradient\n(\nfe_values\n,\n \n1\n,\n \nT\n)\n  \n# value of grad T in 1st quad point\n\n\n2\n-\nelement\n \nContMechTensors\n.\nTensor\n{\n1\n,\n2\n,\nFloat64\n,\n2\n}:\n\n \n0.410202\n\n \n1.1153\n\n\n\n\n\n\nFor a vector valued function:\n\n\njulia\n \nu\n \n=\n \nVec\n{\n2\n,\n \nFloat64\n}[\nVec\n{\n2\n}((\n0.0\n,\n \n0.0\n)),\n\n                          \nVec\n{\n2\n}((\n3.5\n,\n \n2.0\n)),\n\n                          \nVec\n{\n2\n}((\n2.0\n,\n \n2.0\n)),\n\n                          \nVec\n{\n2\n}((\n2.0\n,\n \n1.0\n))];\n\n\n\njulia\n \nfunction_vector_value\n(\nfe_values\n,\n \n2\n,\n \nu\n)\n\n\n2\n-\nelement\n \nContMechTensors\n.\nTensor\n{\n1\n,\n2\n,\nFloat64\n,\n2\n}:\n\n \n2.59968\n\n \n1.62201\n\n\n\njulia\n \nfunction_vector_symmetric_gradient\n(\nfe_values\n,\n \n3\n,\n \nu\n)\n\n\n2\nx2\n \nContMechTensors\n.\nSymmetricTensor\n{\n2\n,\n2\n,\nFloat64\n,\n3\n}:\n\n \n-\n0.0443518\n  \n0.713306\n\n  \n0.713306\n   \n0.617741\n\n\n\n\n\n\nFor more functions see  the documentation for \nFEValues", 
            "title": "Basic usage"
        }, 
        {
            "location": "/man/basic_usage/#basic-usage", 
            "text": "Create a quadrature rule:  julia   quad_rule   =   QuadratureRule (: legendre ,   Dim { 2 },   RefCube (),   2 );   Create a function space  julia   func_space   =   Lagrange { 2 ,   RefCube ,   1 }()   Use these to create a  FEValues  object.  julia   fe_values   =   FEValues ( quad_rule ,   func_space );   Use  reinit!  to update  fe_values  on an element:  julia   x   =   Vec { 2 ,   Float64 }[ Vec { 2 }(( 0.0 ,   0.0 )), \n                            Vec { 2 }(( 1.5 ,   0.0 )), \n                            Vec { 2 }(( 2.0 ,   2.0 )), \n                            Vec { 2 }(( 0.0 ,   1.0 ))];  julia   reinit! ( fe_values ,   x );   We can now query the  FEValues  object for shape function information:  Values of shape functions in quadrature point 3  julia   shape_value ( fe_values ,   3 )  4 - element   Array { Float64 , 1 }: \n  0.166667 \n  0.0446582 \n  0.166667 \n  0.622008   Derivatives of shape function 2 in quadrature point 1    julia   shape_gradient ( fe_values ,   1 ,   2 )  2 - element   ContMechTensors . Tensor { 1 , 2 , Float64 , 2 }: \n   0.520116 \n  - 0.219827   We can also evaluate values and gradients of functions on the finite element basis:  julia   T   =   [ 0.0 ,   1.0 ,   2.0 ,   1.5 ];  julia   function_scalar_value ( fe_values ,   3 ,   T )   # value of T in 3rd quad point  1.311004233964073  julia   function_scalar_gradient ( fe_values ,   1 ,   T )    # value of grad T in 1st quad point  2 - element   ContMechTensors . Tensor { 1 , 2 , Float64 , 2 }: \n  0.410202 \n  1.1153   For a vector valued function:  julia   u   =   Vec { 2 ,   Float64 }[ Vec { 2 }(( 0.0 ,   0.0 )), \n                           Vec { 2 }(( 3.5 ,   2.0 )), \n                           Vec { 2 }(( 2.0 ,   2.0 )), \n                           Vec { 2 }(( 2.0 ,   1.0 ))];  julia   function_vector_value ( fe_values ,   2 ,   u )  2 - element   ContMechTensors . Tensor { 1 , 2 , Float64 , 2 }: \n  2.59968 \n  1.62201  julia   function_vector_symmetric_gradient ( fe_values ,   3 ,   u )  2 x2   ContMechTensors . SymmetricTensor { 2 , 2 , Float64 , 3 }: \n  - 0.0443518    0.713306 \n   0.713306     0.617741   For more functions see  the documentation for  FEValues", 
            "title": "Basic Usage"
        }, 
        {
            "location": "/lib/maintypes/", 
            "text": "Main Types\n\n\n\n\nJuAFEM.AbstractRefShape\n\n\nJuAFEM.FunctionSpace\n\n\nJuAFEM.QuadratureRule\n\n\n\n\nDim\nAbstractRefShape\nQuadratureRule\nFunctionSpace\nFEValues", 
            "title": "Main types"
        }, 
        {
            "location": "/lib/maintypes/#main-types", 
            "text": "JuAFEM.AbstractRefShape  JuAFEM.FunctionSpace  JuAFEM.QuadratureRule   Dim\nAbstractRefShape\nQuadratureRule\nFunctionSpace\nFEValues", 
            "title": "Main Types"
        }, 
        {
            "location": "/lib/utility_functions/", 
            "text": "Utilities\n\n\n\n\nJuAFEM.shape_derivative\n\n\nJuAFEM.shape_divergence\n\n\nJuAFEM.shape_gradient\n\n\nJuAFEM.shape_value\n\n\nWriteVTK.vtk_grid\n\n\n\n\n\n\nQuadratureRule\n\n\npoints\nweights\n\n\n\n\n\n\n\nFEValues\n\n\nget_quadrule\nget_functionspace\ndetJdV\n\nshape_value\nshape_gradient\nshape_divergence\nshape_derivative\n\nfunction_scalar_value\nfunction_vector_value\nfunction_scalar_gradient\nfunction_vector_divergence\nfunction_vector_gradient\nfunction_vector_symmetric_gradient\n\n\n\n\n\n\n\nVTK\n\n\n#\n\n\nWriteVTK.vtk_grid\n \n \nFunction\n.\n\n\nCreates an unstructured VTK grid from the element topology and coordinates.\n\n\nvtk_grid{dim,T}(filename::AbstractString, coords::Vector{Vec{dim,T}}, topology::Matrix{Int}, celltype::VTKCellTypes.VTKCellType)\n\n\n\n\n\nArguments\n\n\n\n\nfilename\n Name (or path) of the file when it is saved to disk, eg \nfilename = \"myfile\"\n, or \nfilename = \"/results/myfile\"\n to store it in the folder results\n\n\ncoords\n A vector of the node coordinates\n\n\ntopology\n A matrix where each column contains the nodes which connects the element\n\n\ncelltype\n The definition of the celltype in the grid, see \nhttps://github.com/jipolanco/WriteVTK.jl#defining-cells\n\n\n\n\nResults:\n\n\n\n\n::DatasetFile\n\n\n\n\nExample:\n\n\njulia\n \ncoords\n \n=\n \n[\nVec\n{\n2\n}((\n0.0\n,\n0.0\n)),\n \nVec\n{\n2\n}((\n1.0\n,\n0.0\n)),\n \nVec\n{\n2\n}((\n1.5\n,\n1.5\n)),\n \nVec\n{\n2\n}((\n0.0\n,\n1.0\n))]\n\n\n4\n-\nelement\n \nArray\n{\nContMechTensors\n.\nTensor\n{\n1\n,\n2\n,\nFloat64\n,\n2\n},\n1\n}:\n\n \n[\n0.0\n,\n0.0\n]\n\n \n[\n1.0\n,\n0.0\n]\n\n \n[\n1.5\n,\n1.5\n]\n\n \n[\n0.0\n,\n1.0\n]\n\n\n\njulia\n \ntopology\n \n=\n \n[\n1\n \n2\n \n4\n;\n \n2\n \n3\n \n4\n]\n\n\n3\n\u00d72\n \nArray\n{\nInt64\n,\n2\n}:\n\n \n1\n  \n2\n\n \n2\n  \n3\n\n \n4\n  \n4\n\n\n\njulia\n \ncelltype\n \n=\n \nVTKCellTypes\n.\nVTK_TRIANGLE\n;\n\n\n\njulia\n \nvtkobj\n \n=\n \nvtk_grid\n(\nexample\n,\n \ncoords\n,\n \ntopology\n,\n \ncelltype\n);\n\n\n\njulia\n \nvtk_save\n(\nvtkobj\n)\n\n\n1\n-\nelement\n \nArray\n{\nString\n,\n1\n}:\n\n \nexample.vtu\n\n\n\n\n\n\nDetails\n\n\nThis is a thin wrapper around the \nvtk_grid\n function from the \nWriteVTK\n package.\n\n\nFor information how to add cell data and point data to the resulting VTK object as well as how to write it to a file see \nhttps://github.com/jipolanco/WriteVTK.jl#generating-an-unstructured-vtk-file\n\n\nsource", 
            "title": "Utility functions"
        }, 
        {
            "location": "/lib/utility_functions/#utilities", 
            "text": "JuAFEM.shape_derivative  JuAFEM.shape_divergence  JuAFEM.shape_gradient  JuAFEM.shape_value  WriteVTK.vtk_grid", 
            "title": "Utilities"
        }, 
        {
            "location": "/lib/utility_functions/#quadraturerule", 
            "text": "points\nweights", 
            "title": "QuadratureRule"
        }, 
        {
            "location": "/lib/utility_functions/#fevalues", 
            "text": "get_quadrule\nget_functionspace\ndetJdV\n\nshape_value\nshape_gradient\nshape_divergence\nshape_derivative\n\nfunction_scalar_value\nfunction_vector_value\nfunction_scalar_gradient\nfunction_vector_divergence\nfunction_vector_gradient\nfunction_vector_symmetric_gradient", 
            "title": "FEValues"
        }, 
        {
            "location": "/lib/utility_functions/#vtk", 
            "text": "#  WriteVTK.vtk_grid     Function .  Creates an unstructured VTK grid from the element topology and coordinates.  vtk_grid{dim,T}(filename::AbstractString, coords::Vector{Vec{dim,T}}, topology::Matrix{Int}, celltype::VTKCellTypes.VTKCellType)  Arguments   filename  Name (or path) of the file when it is saved to disk, eg  filename = \"myfile\" , or  filename = \"/results/myfile\"  to store it in the folder results  coords  A vector of the node coordinates  topology  A matrix where each column contains the nodes which connects the element  celltype  The definition of the celltype in the grid, see  https://github.com/jipolanco/WriteVTK.jl#defining-cells   Results:   ::DatasetFile   Example:  julia   coords   =   [ Vec { 2 }(( 0.0 , 0.0 )),   Vec { 2 }(( 1.0 , 0.0 )),   Vec { 2 }(( 1.5 , 1.5 )),   Vec { 2 }(( 0.0 , 1.0 ))]  4 - element   Array { ContMechTensors . Tensor { 1 , 2 , Float64 , 2 }, 1 }: \n  [ 0.0 , 0.0 ] \n  [ 1.0 , 0.0 ] \n  [ 1.5 , 1.5 ] \n  [ 0.0 , 1.0 ]  julia   topology   =   [ 1   2   4 ;   2   3   4 ]  3 \u00d72   Array { Int64 , 2 }: \n  1    2 \n  2    3 \n  4    4  julia   celltype   =   VTKCellTypes . VTK_TRIANGLE ;  julia   vtkobj   =   vtk_grid ( example ,   coords ,   topology ,   celltype );  julia   vtk_save ( vtkobj )  1 - element   Array { String , 1 }: \n  example.vtu   Details  This is a thin wrapper around the  vtk_grid  function from the  WriteVTK  package.  For information how to add cell data and point data to the resulting VTK object as well as how to write it to a file see  https://github.com/jipolanco/WriteVTK.jl#generating-an-unstructured-vtk-file  source", 
            "title": "VTK"
        }, 
        {
            "location": "/LICENSE/", 
            "text": "The JuAFEM.jl package is licensed under the MIT \"Expat\" License:\n\n\n\n\nCopyright (c) 2015-2016: Kristoffer Carlsson.\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.", 
            "title": "License"
        }
    ]
}